#include "sql_handler.h"
#include <iostream>
#include <stdexcept>
#include <algorithm>
#include <filesystem>
#include "utils.h"

std::vector<std::pair<int64_t, int64_t>> SQLHandler::shamirSecretSharing(int64_t& secret, int n, int k) {
    std::vector<int64_t> coefficients(k - 1);
    std::vector<std::pair<int64_t, int64_t>> shares;

    // Fixed random number generator using the secret, the number of shares n and the minimum share needed for reconstruction k
    std::mt19937 gen(static_cast<uint32_t>(secret) ^ n ^ k);
    std::uniform_int_distribution<> dis(1, 100);

    coefficients[0] = secret;
    for (int i = 1; i < k; ++i) {
        coefficients[i] = dis(gen); // So in the case, for k = 3 we have 2 coefficients, at 0 index we have the secret, at 1 index we have the first coefficient
    }

    // Generate shares
    for (int64_t x = 1; x <= n; ++x) {
        int64_t y = 0;
        for (int i = 0; i < k; ++i) {
            y += coefficients[i] * std::pow(x, i); // For the first share, we have x = 1, so we have y = coefficients[0] + coefficients[1] + coefficients[2]
                                                   // where coefficients[0] is the secret, coefficients[1] is the random integer generated by std::uniform_int_distribution<> dis(1, INT32_MAX)
        }
        shares.emplace_back(x, y);
    }
        // Print out the shares
    // for (const auto& share : shares) {
    //     std::cout << "Share: (" << share.first << ", " << share.second << ")" << std::endl;
    // }
    return shares;
}

// Function to convert string to integer (simple example using ASCII values)
int64_t stringToInt(const std::string& str) {
    int64_t result = 0;
    for (char c : str) {
        result = result * 256 + static_cast<int>(c);
    }
    return result;
}

SQLHandler::SQLHandler() = default;
SQLHandler::~SQLHandler() = default;

void SQLHandler::setSelectItems(const std::vector<Utils::SelectItem>& items) { selectItems = items; }
void SQLHandler::setFilterItems(const std::vector<Utils::FilterItem>& items) { filterItems = items; }
void SQLHandler::setAttributeSecrets(const std::string& secrets) { attributeSecrets.emplace_back(secrets); }
void SQLHandler::setConditionSecrets(const int64_t& secrets) { conditionSecrets.emplace_back(secrets); }
void SQLHandler::setWhereClauses(const std::string& clauses) { whereClauses = clauses; }

AtrributeID SQLHandler::attributeStringToEnum(const std::string& attr) {
    static const std::unordered_map<std::string, AtrributeID> attrMap = {
        {"ORDERKEY", orderKeyID},
        {"PARTKEY", partKeyID},
        {"SUPPKEY", suppKeyID},
        {"LINENUMBER", lineNumberID},
        {"QUANTITY", quantityID},
        {"EXTENDEDPRICE", extendedPriceID},
        {"DISCOUNT", discountID},
        {"TAX", taxID},
        {"RETURNFLAG", returnFlagID},
        {"LINESTATUS", lineStatusID},
        {"SHIPDATE", shipDateID},
        {"COMMITDATE", commitDateID},
        {"RECEIPTDATE", receiptDateID},
        {"SHIPINSTRUCT", shipInStructID},
        {"SHIPMODE", shipModeID},
        {"COMMENT", commentID},
        {"ALL", allID}
    };
    auto it = attrMap.find(attr);
    if (it != attrMap.end()) {
        return it->second;
    }
    throw std::invalid_argument("Unknown attribute: " + attr);
}

int main () {
    // Intialize SQLHandler
    SQLHandler sqlHandler;
    //std::unique_ptr<SQLHandler> sqlHandler = std::make_unique<SQLHandler>;
    namespace fs = std::filesystem;
    std::vector<int64_t> conditionals;
    std::string outputDir = "../Shamir_Search_Results";
    std::filesystem::create_directory(outputDir);
    std::vector<std::pair<int64_t, int64_t>> secretShares;
    std::pair<Utils::SelectItem, std::vector<Utils::FilterItem>> combinedItems;


    // Create a vector to hold all the combined items
    std::vector<std::pair<Utils::SelectItem, std::vector<Utils::FilterItem>>> allItemsList;
    try {
        std::string queriesRoot = "../SQL_Queries";
        for (const auto& dirEntry : fs::recursive_directory_iterator(queriesRoot)) {
            if (dirEntry.is_regular_file() && dirEntry.path().extension() == ".json") {
                std::vector<Utils::SelectItem> selectItems;
                std::vector<Utils::FilterItem> filterItems;
                Utils::parseQueryJson(dirEntry.path().string(), selectItems, filterItems, combinedItems);

                std::cout << "Parsed: " << dirEntry.path() << std::endl;
                allItemsList.emplace_back(combinedItems);
            }
        }
        // Now selectItems and filterItems are populated from the JSON file
        for (const auto& item : allItemsList) {
            secretShares.clear(); // Clear secret shares for each item
            conditionals.clear();
            const auto& selectItem = item.first;
            std::cout << "Select: " << selectItem.query_type << ", " << selectItem.attribute << ", " << selectItem.variable << std::endl;
            for (const auto& item : item.second) {
                std::cout << "Filter: " << item.attribute << " = " << item.condition << ", whereClause: " << item.whereClause << std::endl;
                if (!item.attribute.empty()) {
                    sqlHandler.setAttributeSecrets(item.attribute);
                }
                if (!item.condition.empty()) {
                    sqlHandler.setConditionSecrets(static_cast<int64_t>(stringToInt(item.condition))); // Casting to ASCII value to match secret sharing
                    conditionals.emplace_back(static_cast<int64_t>(stringToInt(item.condition))); // Used for persistance by saving in a file.
                }
            }
            // Calculate the secret shares for each conditional value
            for (auto cond : conditionals) {
                std::cout << "Condition secret: " << cond << std::endl;
                auto shares = sqlHandler.shamirSecretSharing(cond, 6, 3);
                secretShares.insert(secretShares.end(), shares.begin(), shares.end());
            }

            std::cout << "Count query for attribute: " << selectItem.attribute << std::endl;

            // Write results to a text file for parsing later
            std::ofstream file (outputDir + "/Shares_" + selectItem.query_type + ".txt", std::ios::app);
            if (file.is_open()) {
                for (const auto& share : secretShares) {
                    file << share.first << "|" << share.second << "\n"; // Write each share to the file
                }
                file.close();
                std::cout << "Shares written to: " << outputDir + "/Shares_" + selectItem.query_type + ".txt" << std::endl;
            } else {
                std::cerr << "Error opening output file." << std::endl;
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}