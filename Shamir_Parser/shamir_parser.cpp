#include "shamir_parser.h"
#include <filesystem>
#include <future>

std::vector<LineItem> ShamirParser::parseLineItemFile(const std::string& filename) {
    std::vector<LineItem> lineItems;
    std::ifstream file(filename);
    std::string line;

    while (std::getline(file, line)) {
        std::istringstream iss(line);
        std::string token;
        LineItem item;

        std::getline(iss, token, '|'); item.L_ORDERKEY = std::stoi(token);
        std::getline(iss, token, '|'); item.L_PARTKEY = std::stoi(token);
        std::getline(iss, token, '|'); item.L_SUPPKEY = std::stoi(token);
        std::getline(iss, token, '|'); item.L_LINENUMBER = std::stoi(token);
        std::getline(iss, token, '|'); item.L_QUANTITY = std::stoi(token);
        std::getline(iss, token, '|'); item.L_EXTENDEDPRICE = std::stod(token);
        std::getline(iss, token, '|'); item.L_DISCOUNT = std::stod(token);
        std::getline(iss, token, '|'); item.L_TAX = std::stod(token);
        std::getline(iss, token, '|'); item.L_RETURNFLAG = token;
        std::getline(iss, token, '|'); item.L_LINESTATUS = token;
        std::getline(iss, token, '|'); item.L_SHIPDATE = token;
        std::getline(iss, token, '|'); item.L_COMMITDATE = token;
        std::getline(iss, token, '|'); item.L_RECEIPTDATE = token;
        std::getline(iss, token, '|'); item.L_SHIPINSTRUCT = token;
        std::getline(iss, token, '|'); item.L_SHIPMODE = token;
        std::getline(iss, token, '|'); item.L_COMMENT = token;

        lineItems.push_back(item);
    }

    return lineItems;
}

template <typename T>
std::unordered_map<T, int> ShamirParser::mapUniqueValues(const std::vector<T>& values) {
    std::unordered_map<T, int> value_map;
    int counter = 1;

    for (const auto& value : values) {
        if (value_map.find(value) == value_map.end()) {
            value_map[value] = counter++;
        }
    }

    return value_map;
}

std::vector<std::pair<int64_t, int64_t>> ShamirParser::shamirSecretSharingDouble(double& secret, int n, int k) {
    std::vector<int64_t> coefficients(k);
    std::vector<std::pair<int64_t, int64_t>> shares;

    // Fixed random number generator using the secret, the number of shares n and the minimum share needed for reconstruction k
    std::mt19937 gen(static_cast<uint32_t>(secret) ^ n ^ k);
    std::uniform_int_distribution<int64_t> dis(0, 100);

    coefficients[0] = static_cast<int64_t>(secret * 100); // Scale the floating point value
    for (int i = 1; i < k; ++i) {
        coefficients[i] = dis(gen);
    }

    // Generate shares
    for (int64_t x = 1; x <= n; ++x) {
        int64_t y = 0;
        for (int i = 0; i < k; ++i) {
            y += coefficients[i] * std::pow(x, i);;
        }
        shares.emplace_back(x,y);
    }

    return shares;
}

std::vector<std::pair<int64_t, int64_t>> ShamirParser::shamirSecretSharing(int64_t& secret, int n, int k) {
    std::vector<int64_t> coefficients(k - 1);
    std::vector<std::pair<int64_t, int64_t>> shares;

    // Fixed random number generator using the secret, the number of shares n and the minimum share needed for reconstruction k
    std::mt19937 gen(static_cast<uint32_t>(secret) ^ n ^ k);
    std::uniform_int_distribution<> dis(1, 100);

    coefficients[0] = secret;
    for (int i = 1; i < k; ++i) {
        coefficients[i] = dis(gen); // So in the case, for k = 3 we have 2 coefficients, at 0 index we have the secret, at 1 index we have the first coefficient
    }

    // Generate shares
    for (int64_t x = 1; x <= n; ++x) {
        int64_t y = 0;
        for (int i = 0; i < k; ++i) {
            y += coefficients[i] * std::pow(x, i); // For the first share, we have x = 1, so we have y = coefficients[0] + coefficients[1] + coefficients[2]
                                                   // where coefficients[0] is the secret, coefficients[1] is the random integer generated by std::uniform_int_distribution<> dis(1, INT32_MAX)
        }
        shares.emplace_back(x, y);
    }

    return shares;
}

double ShamirParser::reconstructSecretFloat(const std::vector<std::pair<int64_t, int64_t>>& shares, int k) {
    double secret = 0;

    for (int i = 0; i < k; ++i) {
        double lagrange_coeff = 1.0;

        for (int j = 0; j < k; ++j) {
            if (i != j) {
                lagrange_coeff *= static_cast<double>(-shares[j].first) / (shares[i].first - shares[j].first);
            }
        }

        secret = secret + shares[i].second * lagrange_coeff;
    }

    return static_cast<double>((secret ) / 100.0); // Scale back to floating point
}

// Reconstruction (using Lagrange interpolation)
int64_t ShamirParser::reconstructSecret(const std::vector<std::pair<int64_t, int64_t>>& shares, int k) {
    double secret = 0;
    // Shares are pairs of (x, y) where x is the share index and y is the share value
    // k is the minimum number of shares needed to reconstruct the secret
    // Lagrange interpolation formula: P(x) = Σ y_i * l_i(x)
    // where l_i(x) = Π (x - x_j) / (x_i - x_j) for j ≠ i
    // P(x) is the polynomial that passes through the points (x_i, y_i)
    // We can reconstruct the secret by evaluating the polynomial at x = 0
    for (int i = 0; i < k; ++i) {
        double lagrange_coeff = 1.0;

        for (int j = 0; j < k; ++j) {
            if (i != j) {
                lagrange_coeff *= static_cast<double>(-shares[j].first) / (shares[i].first - shares[j].first);
            }
        }

        secret += shares[i].second * lagrange_coeff;
    }

    return static_cast<int64_t>(std::round(secret));
}

// Function to convert date string to Unix timestamp
int64_t ShamirParser::dateToTimestamp(const std::string& date) {
    std::tm tm = {};
    std::istringstream ss(date);
    ss >> std::get_time(&tm, "%Y-%m-%d");
    return std::mktime(&tm);
}

// Convert Unix timestamp to date string
std::string ShamirParser::timestampToDate(int64_t timestamp) {
    std::time_t time = timestamp;
    std::tm* tm = std::localtime(&time);
    std::ostringstream ss;
    ss << std::put_time(tm, "%Y-%m-%d");
    return ss.str();
}

// Function to convert string to integer (simple example using ASCII values)
int64_t ShamirParser::stringToInt(const std::string& str) {
    int64_t result = 0;
    for (char c : str) {
        result = result * 256 + static_cast<int>(c);
    }
    return result;
}

// Convert integer to string
std::string ShamirParser::intToString(int64_t value) {
    std::string result;
    while (value > 0) {
        result = static_cast<char>(value % 256) + result;
        value /= 256;
    }
    return result;
}

std::vector<std::vector<std::pair<int64_t, int64_t>>> ShamirParser::shamirSecretSharingAllAttributes(const LineItem& item, int n, int k) {
    std::vector<std::vector<std::pair<int64_t, int64_t>>> allShares(16);
    // Max value of int64_t is 2^63 - 1 = 9223372036854775807

    auto shareAttributeInt = [&](int64_t secret) {
        return shamirSecretSharing(secret, n, k);
    };

    auto shareAttributeDouble = [&](double secret) {
        return shamirSecretSharingDouble(secret, n, k);
    };

    allShares[0] = shareAttributeInt(item.L_ORDERKEY);
    allShares[1] = shareAttributeInt(item.L_PARTKEY);
    allShares[2] = shareAttributeInt(item.L_SUPPKEY);
    allShares[3] = shareAttributeInt(item.L_LINENUMBER);
    allShares[4] = shareAttributeInt(item.L_QUANTITY);
    allShares[5] = shareAttributeInt(item.L_EXTENDEDPRICE);
    allShares[6] = shareAttributeDouble(item.L_DISCOUNT);
    allShares[7] = shareAttributeDouble(item.L_TAX);
    allShares[8] = shareAttributeInt(item.L_RETURNFLAG[0]);
    allShares[9] = shareAttributeInt(item.L_LINESTATUS[0]);
    allShares[10] = shareAttributeInt(dateToTimestamp(item.L_SHIPDATE));
    allShares[11] = shareAttributeInt(dateToTimestamp(item.L_COMMITDATE));
    allShares[12] = shareAttributeInt(dateToTimestamp(item.L_RECEIPTDATE));
    allShares[13] = shareAttributeInt(stringToInt(item.L_SHIPINSTRUCT));
     allShares[14] = shareAttributeInt(stringToInt(item.L_SHIPMODE));
     allShares[15] = shareAttributeInt(stringToInt(item.L_COMMENT));

    return allShares;
}

// Function to save shares to files
void ShamirParser::saveAllShares(const std::vector<std::vector<std::pair<int64_t, int64_t>>>& allShares) {
    std::string baseDir = "../shares";

    // Creating the directory if it doesn't exist
    std::filesystem::create_directory(baseDir);

    for (size_t i = 0; i < allShares[0].size(); ++i) { // Parse for each share
        std::ofstream file(baseDir + "/server_" + std::to_string(i + 1) + ".txt", std::ios::app);
        if (file.is_open()) {
            for (const auto& shares : allShares) {
                file << "|" << " "<< shares[i].second << " ";
            }
            file << "\n";
            file.close();
        }
    }
}

std::vector<std::vector<std::vector<int64_t>>> ShamirParser::loadAllShares(int n) {
    std::vector<std::vector<std::vector<int64_t>>> allShares(n);
// The format of allShares is as follows:
// Inner most vector contains the shares for a single tuple, in total 16 shares attributes
// Middle vector contains all the tuples for a single server, in total n tuples 
// Outer most vector must contain shares of total n servers, in our case n = 6
std::string baseDir = "../shares"; // Relative path to the shares directory

    for (int serverIndex = 1; serverIndex < n; ++serverIndex) {
        std::string filePath = baseDir + "/server_" + std::to_string(serverIndex) + ".txt";
        std::ifstream file(filePath, std::ios::in);
        if (file.is_open()) {
            std::string line;
            while (std::getline(file, line)) {
                std::istringstream iss(line);
                std::string y_str;
                std::vector<int64_t> tupleShares;
                while (std::getline(iss, y_str, '|')) {
                    // Trim leading and trailing whitespace
                    y_str.erase(0, y_str.find_first_not_of(" \t\n\r"));
                    y_str.erase(y_str.find_last_not_of(" \t\n\r") + 1);

                    if (!y_str.empty()) {
                        tupleShares.push_back(std::stoll(y_str));
                    }
                }
                allShares[serverIndex - 1].push_back({tupleShares});
            }
            file.close();
        } else {
            std::cerr << "Error opening file: server_" << serverIndex << ".txt" << std::endl;
        }
    }

    return allShares;
}

std::vector<std::vector<std::vector<std::pair<int64_t, int64_t>>>> ShamirParser::transformShares(const std::vector<std::vector<std::vector<int64_t>>>& allShares) {
    std::vector<std::vector<std::vector<std::pair<int64_t, int64_t>>>> transformedShares;

    if (allShares.empty()) {
        std::cerr << "Error: No shares to transform." << std::endl;
        return transformedShares;
    }
    
    size_t numServers = allShares.size(); // The size of allShares.size is 6, which is the number of servers
    size_t numTuples = allShares[0].size(); // The size of allShares[0].size() is n, which is the number of tuples
    size_t numAttributes = allShares[0][0].size(); // Number of attributes, should be 16

    transformedShares.resize(numAttributes);

    for (size_t attributeIndex = 0; attributeIndex < numAttributes; ++attributeIndex) {
        transformedShares[attributeIndex].resize(numTuples);
        for (size_t tupleIndex = 0; tupleIndex < numTuples; ++tupleIndex) {
            for (size_t serverIndex = 0; serverIndex < numServers; ++serverIndex) {
                if (serverIndex < allShares.size() && tupleIndex < allShares[serverIndex].size() && attributeIndex < allShares[serverIndex][tupleIndex].size()) {
                    transformedShares[attributeIndex][tupleIndex].emplace_back(serverIndex + 1, allShares[serverIndex][tupleIndex][attributeIndex]);
                }
            }
        }
    }    

    return transformedShares;
}

int main(int argc, char** argv) {
    if (argc != 3) {
        std::cout << "Usage: " << argv[0] << " <encrypt/decrypt> <file>" << std::endl;
        return 1;
    }

    std::string option = argv[1];
    std::string filename = argv[2];
    ShamirParser parser;
    std::string baseDir = "../metrics";

    // Creating the directory if it doesn't exist
    std::filesystem::create_directory(baseDir);
    std::ofstream file (baseDir + "/metrics.txt", std::ios::app);
    if (!file.is_open()) {
        std::cerr << "Error opening metrics file." << std::endl;
        return 1;
    }

    if (option == "encrypt") {
        auto start = std::chrono::high_resolution_clock::now(); // Start timing
        auto lineItems = parser.parseLineItemFile(filename);
        std::cout << "Line item size:" << lineItems.size() << std::endl;

        for (size_t i = 0; i < lineItems.size(); ++i) {
            auto allShares = parser.shamirSecretSharingAllAttributes(lineItems[i], 6, 3);
            parser.saveAllShares(allShares);
        }
        
        // Much quicker way to save shares using multithreading
        // size_t max_threads = std::thread::hardware_concurrency();
        // if (max_threads == 0) max_threads = 4; // fallback
        // std::vector<std::future<void>> futures;
        // for (size_t i = 0; i < lineItems.size(); ++i) {
        //     if (futures.size() >= max_threads) {
        //         futures.front().get();
        //         futures.erase(futures.begin());
        //     }
        //     futures.push_back(std::async(std::launch::async, [&parser, &lineItems, i]() {
        //         auto allShares = parser.shamirSecretSharingAllAttributes(lineItems[i], 6, 3);
        //         parser.saveAllShares(allShares);
        //     }));
        // }
        // for (auto& f : futures) f.get();

        auto end = std::chrono::high_resolution_clock::now(); // End timing
        std::chrono::duration<double> elapsed = end - start;
        std::cout << "Time taken to create secret shares: " << elapsed.count() << " seconds" << std::endl;
        file << "Encrypt: Time taken to create secret shares: " << elapsed.count() << " seconds" << std::endl;

    } else if (option == "decrypt") {
        auto start = std::chrono::high_resolution_clock::now(); // Start timing
        std::vector<LineItem> reconstructedItems;

        //for (size_t tupleIndex = 1; ; ++tupleIndex) {
            auto tempShares = parser.loadAllShares(6);
            auto allShares = parser.transformShares(tempShares);
        // Push all shares into lineitem
        for (size_t i = 0; i < tempShares[0].size(); ++i) {
            LineItem item;
            item.L_ORDERKEY = parser.reconstructSecret(allShares[0][i], 3);
            item.L_PARTKEY = parser.reconstructSecret(allShares[1][i], 3);
            item.L_SUPPKEY = parser.reconstructSecret(allShares[2][i], 3);
            item.L_LINENUMBER = parser.reconstructSecret(allShares[3][i], 3);
            item.L_QUANTITY = parser.reconstructSecret(allShares[4][i], 3);
            item.L_EXTENDEDPRICE = parser.reconstructSecret(allShares[5][i], 3);
            item.L_DISCOUNT = parser.reconstructSecretFloat(allShares[6][i], 3);
            item.L_TAX = parser.reconstructSecretFloat(allShares[7][i], 3);
            item.L_RETURNFLAG = static_cast<char>(parser.reconstructSecret(allShares[8][i], 3));
            item.L_LINESTATUS = static_cast<char>(parser.reconstructSecret(allShares[9][i], 3));
            item.L_SHIPDATE = parser.timestampToDate(parser.reconstructSecret(allShares[10][i], 3));
            item.L_COMMITDATE = parser.timestampToDate(parser.reconstructSecret(allShares[11][i], 3));
            item.L_RECEIPTDATE = parser.timestampToDate(parser.reconstructSecret(allShares[12][i], 3));
            item.L_SHIPINSTRUCT = parser.intToString(parser.reconstructSecret(allShares[13][i], 3));
            item.L_SHIPMODE = parser.intToString(parser.reconstructSecret(allShares[14][i], 3));
            item.L_COMMENT = parser.intToString(parser.reconstructSecret(allShares[15][i], 3));

            reconstructedItems.push_back(item);
        }

        std::ofstream outputFile(filename);
        if (outputFile.is_open()) {
            for (const auto& item : reconstructedItems) {
                outputFile << item.L_ORDERKEY << "|" << item.L_PARTKEY << "|" << item.L_SUPPKEY << "|" << item.L_LINENUMBER << "|"
                           << item.L_QUANTITY << "|" << item.L_EXTENDEDPRICE << "|" << item.L_DISCOUNT << "|" << item.L_TAX << "|"
                           << item.L_RETURNFLAG << "|" << item.L_LINESTATUS << "|" << item.L_SHIPDATE << "|" << item.L_COMMITDATE << "|"
                           << item.L_RECEIPTDATE << "|" << item.L_SHIPINSTRUCT << "|" << item.L_SHIPMODE << "|" << item.L_COMMENT << "\n";
            }
            outputFile.close();
        } else {
            std::cerr << "Error opening output file: " << filename << std::endl;
            return 1;
        }
        std::cout << "Reconstructed tuples written to: " << filename << std::endl;

        auto end = std::chrono::high_resolution_clock::now(); // End timing
        std::chrono::duration<double> elapsed = end - start;
        std::cout << "Time taken to decrypt and reconstruct: " << elapsed.count() << " seconds" << std::endl;
        file << "Decrypt: Time taken to decrypt and reconstruct: " << elapsed.count() << " seconds" << std::endl;
    } else {
        std::cout << "Invalid option." << std::endl;
        return 1;
    }
    file.close();
    return 0;
}