#include "sql_handler.h"
#include <iostream>
#include <stdexcept>
#include <algorithm>
#include <filesystem>
#include "utils.h"

std::variant<int64_t, double> SQLHandler::executeAggregationQuery(const std::string& query) {
    std::string upperQuery = query;
    std::transform(upperQuery.begin(), upperQuery.end(), upperQuery.begin(), ::toupper);

    if (upperQuery.find("COUNT") == 0) {
        return convertCountORAMQuery(query);
    } else if (upperQuery.find("SUM") == 0) {
        return convertSumORAMQuery(query);
    } else if (upperQuery.find("AVG") == 0) {
        return convertAvgORAMQuery(query);
    } else if (upperQuery.find("MIN") == 0) {
        return convertMinORAMQuery(query);
    } else if (upperQuery.find("MAX") == 0) {
        return convertMaxORAMQuery(query);
    } else {
        throw std::invalid_argument("Unsupported aggregation query");
    }
}

std::vector<std::pair<int64_t, int64_t>> SQLHandler::shamirSecretSharing(int64_t& secret, int n, int k) {
    std::vector<int64_t> coefficients(k - 1);
    std::vector<std::pair<int64_t, int64_t>> shares;

    // Fixed random number generator using the secret, the number of shares n and the minimum share needed for reconstruction k
    std::mt19937 gen(static_cast<uint32_t>(secret) ^ n ^ k);
    std::uniform_int_distribution<> dis(1, 100);

    coefficients[0] = secret;
    for (int i = 1; i < k; ++i) {
        coefficients[i] = dis(gen); // So in the case, for k = 3 we have 2 coefficients, at 0 index we have the secret, at 1 index we have the first coefficient
    }

    // Generate shares
    for (int64_t x = 1; x <= n; ++x) {
        int64_t y = 0;
        for (int i = 0; i < k; ++i) {
            y += coefficients[i] * std::pow(x, i); // For the first share, we have x = 1, so we have y = coefficients[0] + coefficients[1] + coefficients[2]
                                                   // where coefficients[0] is the secret, coefficients[1] is the random integer generated by std::uniform_int_distribution<> dis(1, INT32_MAX)
        }
        shares.emplace_back(x, y);
    }
        // Print out the shares
    // for (const auto& share : shares) {
    //     std::cout << "Share: (" << share.first << ", " << share.second << ")" << std::endl;
    // }
    return shares;
}

SQLHandler::SQLHandler() = default;
SQLHandler::~SQLHandler() = default;

int64_t SQLHandler::convertCountORAMQuery(const std::string& query) {
    // Use selectItems and filterItems as needed
    if (selectItems.empty()) throw std::runtime_error("No select items loaded");
    std::string attribute = selectItems[0].attribute;
    std::string variable = selectItems[0].variable;
    // ... use attribute/variable and filterItems for query logic ...
    return 0; // placeholder
}

int64_t SQLHandler::convertSumORAMQuery(const std::string& query) {
    // TODO: Implement logic
    return 0;
}

double SQLHandler::convertAvgORAMQuery(const std::string& query) {
    // TODO: Implement logic
    return 0.0;
}

int64_t SQLHandler::convertMinORAMQuery(const std::string& query) {
    // TODO: Implement logic
    return 0;
}

int64_t SQLHandler::convertMaxORAMQuery(const std::string& query) {
    // TODO: Implement logic
    return 0;
}

std::vector<std::vector<int64_t>> SQLHandler::getResults() const {
    return results;
}

void SQLHandler::setSelectItems(const std::vector<Utils::SelectItem>& items) { selectItems = items; }
void SQLHandler::setFilterItems(const std::vector<Utils::FilterItem>& items) { filterItems = items; }
void SQLHandler::setAttributeSecrets(const std::string& secrets) { attributeSecrets.emplace_back(secrets); }
void SQLHandler::setConditionSecrets(const int64_t& secrets) { conditionSecrets.emplace_back(secrets); }
void SQLHandler::setWhereClauses(const std::string& clauses) { whereClauses = clauses; }

int main () {
    // Intialize SQLHandler
    SQLHandler sqlHandler;
    namespace fs = std::filesystem;
    //std::vector<Utils::SelectItem> allSelectItems;
    //std::vector<Utils::FilterItem> allFilterItems;
    std::pair<Utils::SelectItem, std::vector<Utils::FilterItem>> combinedItems;
    // Create a vector to hold all the combined items
    std::vector<std::pair<Utils::SelectItem, std::vector<Utils::FilterItem>>> allItemsList;
    try {
        std::string queriesRoot = "../SQL_Queries";
        for (const auto& dirEntry : fs::recursive_directory_iterator(queriesRoot)) {
            if (dirEntry.is_regular_file() && dirEntry.path().extension() == ".json") {
                std::vector<Utils::SelectItem> selectItems;
                std::vector<Utils::FilterItem> filterItems;
                Utils::parseQueryJson(dirEntry.path().string(), selectItems, filterItems, combinedItems);

                // Append to the main vectors
                // allSelectItems.insert(allSelectItems.end(), selectItems.begin(), selectItems.end());
                // allFilterItems.insert(allFilterItems.end(), filterItems.begin(), filterItems.end());

                std::cout << "Parsed: " << dirEntry.path() << std::endl;
                allItemsList.emplace_back(combinedItems);
            }
        }
        // Now selectItems and filterItems are populated from the JSON file
        for (const auto& item : allItemsList) {
            const auto& selectItem = item.first;
            std::cout << "Select: " << selectItem.query_type << ", " << selectItem.attribute << ", " << selectItem.variable << std::endl;
            if (selectItem.query_type == "COUNT") {
                for (const auto& item : item.second) {
                    std::cout << "Filter: " << item.attribute << " = " << item.condition << ", whereClause: " << item.whereClause << std::endl;
                    if (!item.attribute.empty()) {
                        sqlHandler.setAttributeSecrets(item.attribute);
                    }
                    if (!item.condition.empty()) {
                        sqlHandler.setConditionSecrets(static_cast<int64_t>(item.condition[0]));
                    }
                }
                std::vector<int64_t> conditionals = sqlHandler.getConditionSecrets(); // Access condition secrets
                for (auto cond : conditionals) {
                    std::cout << "Condition secret: " << cond << std::endl;
                    sqlHandler.shamirSecretSharing(cond, 6, 3); // Example usage
                }
                sqlHandler.convertCountORAMQuery(selectItem.attribute);
                std::cout << "Count query for attribute: " << selectItem.attribute << std::endl;
                continue; // Skip to next select item
            } else if (selectItem.query_type == "SUM") {
                std::cout << "Sum query for attribute: " << selectItem.attribute << std::endl;
            } else if (selectItem.query_type == "AVG") {
                std::cout << "Average query for attribute: " << selectItem.attribute << std::endl;
            } else if (selectItem.query_type == "MIN") {
                std::cout << "Min query for attribute: " << selectItem.attribute << std::endl;
            } else if (selectItem.query_type == "MAX") {
                std::cout << "Max query for attribute: " << selectItem.attribute << std::endl;
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}